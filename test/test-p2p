#!/bin/env node
/* Copyright (c) 2020, William R. Burdick Jr.
 *
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This program demonstrate a simple chat application using p2p communication.
 *
 */

/*
# CLIENT-TO-SERVER MESSAGES
 
```
  Listen:  [1][FRAMES: 1][PROTOCOL: rest] -- request a listener for a protocol (frames optional)
  Stop:    [2][PROTOCOL: rest]            -- stop listening on PORT
  Close:   [3][ID: 8]                     -- close a stream
  Data:    [4][ID: 8][data: rest]         -- write data to stream
  Connect: [5][FRAMES: 1][PROTOCOL: STR][PEERID: rest] -- connect to another peer (frames optional)
```

# SERVER-TO-CLIENT MESSAGES

```
  Listener Connection:     [1][ID: 8][PROTOCOL: rest]          -- new listener connection with id ID
  Connection Closed:       [2][ID: 8]                          -- connection ID closed
  Data:                    [3][ID: 8][data: rest]              -- receive data from stream with id ID
  Listen Refused:          [4][PROTOCOL: rest]                 -- could not listen on PORT
  Listener Closed:         [5][PROTOCOL: rest]                 -- could not listen on PORT
  Peer Connection:         [6][ID: 8][PROTOCOL: rest]          -- connected to a peer with id ID
  Peer Connection Refused: [7][PEERID: string][PROTOCOL: rest] -- connection to peer PEERID refused
  Protocol Error:          [8][MSG: rest]                      -- error in the protocol
```
*/
"use strict"
const protPat = /^\/x\//
const peerIdPat = /^[^/]+$/
const WebSocket = require('ws');
const path = require('path');
const args = Array.prototype.slice.call(process.argv, 2)
const shortProg = path.basename(process.argv[1], ".js")
const bytes = new ArrayBuffer(8);
const numberConverter = new DataView(bytes);

const cmsg = Object.freeze({
    listen: 0,
    stop: 1,
    close: 2,
    data: 3,
    connect: 4,
});

const smsg = Object.freeze({
    ident: 0,
    listenerConnection: 1,
    connectionClosed: 2,
    data: 3,
    listenRefused: 4,
    listenerClosed: 5,
    peerConnection: 6,
    peerConnectionRefused: 7,
    error: 8,
});

var ws;
var peerId;
var utfDecoder = new TextDecoder("utf-8");
var utfEncoder = new TextEncoder("utf-8");
var connections = new Map();
var connectionHandler = {
    closedConnection: id=>null,
    data: (id, data)=> {
        console.log('Data for ', id, ': ', utfDecoder.decode(data));
        process.exit(0);
    },
};
var sendString = null;

function connectedToServer(prot, id) {
    if (sendString) {
        sendData(id, utfEncoder.encode(sendString), ()=> process.exit(0));
    }
}

function connectionFromPeer(prot, id) {
    if (sendString) {
        sendData(id, utfEncoder.encode(sendString), ()=> process.exit(0));
    }
}

function enumFor(enumObj, value) {
    for (var k in enumObj) {
        if (enumObj[k] == value) return k;
    }
    return null;
}

function sendData(conID, data, cb) {
    var buf = new Uint8Array(9 + data.length);
    var dv = new DataView(buf.buffer);

    console.log("SENDING DATA TO CONNECTION", conID)
    buf[0] = cmsg.data;
    dv.setBigUint64(1, conID);
    buf.set(data, 9)
    ws.send(buf, cb);
}

function connect(urlStr, code) {
    ws = new WebSocket(urlStr);
    ws.on('open', function open() {
        console.log("OPENED CONNECTION");
        code();
    });
    ws.on('message', data=> {
        var dv = new DataView(new Uint8Array(data).buffer);

        console.log("MESSAGE: ", JSON.stringify(data));
        console.log("TYPE: ", enumFor(smsg, data[0]));
        switch (data[0]) {
        case smsg.ident: {
            peerId = utfDecoder.decode(data.slice(1));
            console.log("PEER ID: ", peerId);
            break;
        }
        case smsg.listenerConnection: {
            var id = dv.getBigUint64(1);
            var prot = utfDecoder.decode(data.slice(9));

            connections.set(id, prot);
            connectionHandler.newConnection(id, prot);
            break;
        }
        case smsg.connectionClosed: {
            connectionHandler.closed(id);
            break;
        }
        case smsg.data: {
            var id = dv.getBigUint64(1);
            connectionHandler.data(id, data.slice(9));
            break;
        }
        case smsg.listenRefused:
            break;
        case smsg.listenerClosed:
            break;
        case smsg.peerConnection:
            var conid = dv.getBigUint64(1)
            var prot = utfDecoder.decode(data.slice(9))

            connectedToServer(prot, conid)
            break;
        case smsg.peerConnectionRefused: {
            var prot = getCountedString(dv, 1);
            var peeridStart = prot.length + 2 + 1;
            var peerid = getCountedString(dv, peeridStart);
            var msg = getString(data.slice(peeridStart + peerid.length + 2));

            console.log("Connection refused by peer "+ peerid +" for protocol "+prot+": ("+msg+")");
            break;
        }
        case smsg.error:
            console.log("Error: "+getString(data.slice(1)));
            break;
        }
    });
}

function getCountedString(dv, offset) {
    var start = dv.byteOffset + offset;

    return utfDecoder.decode(dv.buffer.slice(start + 2, start + 2 + dv.getUint16(offset)));
}

function getString(buf) {
    return utfDecoder.decode(buf);
}

function usage(msg) {
    console.log((msg ? msg+"\n\n" : "")+"Usage: "+shortProg+"[--port PORT] <command>\n\n"
                          +"--port PORT                     use PORT to connect to relay (default 8888)\n"
                +shortProg+" send protocol peerid msg...    send some text\n"
                +shortProg+" listen protocol                print text that other peers send");
    if (msg) process.exit(1);
}

function checkProt(str) {
    if (!str.match(protPat)) {
        usage('Bad protocol format, protocols must begin with /x/ but this protocol is '+str);
    }
}

function checkPeerId(str) {
    if (!str.match(peerIdPat)) {
        usage('Bad peer ID format, peer ids must not contain slashes this id is '+str);
    }
}

function runCmdLine() {
    var port = 8888
    var tmpArgs = args

    console.log("ARGS: ", tmpArgs);
    if (args[0] == "--port") {
        port = args[1];
        tmpArgs = args.slice(2);
    }
    connect("ws://localhost:"+port+"/ipfswsrelay", ()=> {
        switch (tmpArgs[0]) {
        case "send":
            if (tmpArgs.length < 4) return usage("Not enough arguments to send");
            var prot = tmpArgs[1];
            var peer = tmpArgs[2];
            checkProt(prot);
            checkPeerId(peer);
            var protEnc = utfEncoder.encode(prot);
            var protLen = protEnc.length;
            console.log("Protocol: ", prot, ", peer: ", peer);
            sendString = tmpArgs[3];
            ws.send(Uint8Array.from([cmsg.connect, 1, Math.trunc(protLen / 256), protLen % 256, ...utfEncoder.encode(prot), ...utfEncoder.encode(peer)]));
            break;
        case "listen":
            if (tmpArgs.length < 2) return usage("Not enough arguments to listen");
            if (tmpArgs.length > 2) return usage("Too many arguments to listen");
            checkProt(tmpArgs[1]);
            ws.send(Uint8Array.from([cmsg.listen, 1, ...utfEncoder.encode(tmpArgs[1])]));
            break;
        default:
            usage();
        }
    });
}

runCmdLine();
